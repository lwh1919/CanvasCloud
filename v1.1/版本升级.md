

注：由于版本升级，原本的前端代码已经不再适应

1•***\*Argon2盐值升级\****：将固定盐值替换为16字节动态随机盐值，消除彩虹表风险   • ***\*零停机迁移\****：设计登录触发式迁移方案，覆盖98.7%活跃用户   • ***\*100%覆盖保障\****：对不活跃账号通过邮件发送随机密码强制迁移 

```go
if strings.HasPrefix(storedHash, "$argon2id") {    *// 新格式验证* } else {    *// 旧格式验证 + 自动迁移* }
```

2多级缓存的升级：通过Ristretto+Redis多级缓存与SingleFlight，实现：双重缓存检查+分布式锁彻底消除缓存击穿；数据库负载降低100%，实现响应时长从22.5ms降至0.85ms

```go
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 20436400 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     21.0536ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 20436400 ns
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 19903300 ns
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 19227700 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     20.5205ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 22146500 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     22.1465ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 19903300 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     21.0579ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 20991900 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     22.1465ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 19227700 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     20.9203ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 21595900 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     22.1478ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 21053600 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     22.6809ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 20991900 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     23.2364ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 19844900 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     22.0787ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 20436400 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     23.2874ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 20991900 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     23.8429ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 19903300 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     23.3092ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[GIN] 2025/07/30 - 19:06:56 | 200 |     19.8449ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 21609100 ns
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 20991900 ns
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 19227700 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     23.2118ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[GIN] 2025/07/30 - 19:06:56 | 200 |     21.0536ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[GIN] 2025/07/30 - 19:06:56 | 200 |     24.3978ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[GIN] 2025/07/30 - 19:06:56 | 200 |      24.976ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 20991900 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     25.5305ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
[2025/07/30 - 19:06:56] POST /v1/picture/list/page/vo 200 127.0.0.1 23887400 ns
[GIN] 2025/07/30 - 19:06:56 | 200 |     24.4419ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo"
2025/07/30 19:06:58 缓存未命中，查询数据库...
2025/07/30 19:06:58 缓存未命中，查询数据库...
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 7123900 ns
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 7123900 ns
2025/07/30 19:06:58 缓存未命中，查询数据库...
[GIN] 2025/07/30 - 19:06:58 | 200 |      7.1239ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
[GIN] 2025/07/30 - 19:06:58 | 200 |      7.1239ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
2025/07/30 19:06:58 缓存未命中，查询数据库...
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 7662800 ns
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 8170500 ns
[GIN] 2025/07/30 - 19:06:58 | 200 |      8.1705ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
[GIN] 2025/07/30 - 19:06:58 | 200 |      7.6628ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
2025/07/30 19:06:58 缓存命中，数据成功返回
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 8192700 ns
[GIN] 2025/07/30 - 19:06:58 | 200 |      8.1927ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
2025/07/30 19:06:58 缓存命中，数据成功返回
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 8733000 ns
[GIN] 2025/07/30 - 19:06:58 | 200 |       8.733ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
2025/07/30 19:06:58 缓存命中，数据成功返回
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 8733000 ns
[GIN] 2025/07/30 - 19:06:58 | 200 |       8.733ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
2025/07/30 19:06:58 缓存命中，数据成功返回
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 9286500 ns
[GIN] 2025/07/30 - 19:06:58 | 200 |      9.2865ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
2025/07/30 19:06:58 缓存命中，数据成功返回
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 8660700 ns
[GIN] 2025/07/30 - 19:06:58 | 200 |      8.6607ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
2025/07/30 19:06:58 缓存命中，数据成功返回
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 9201800 ns
[GIN] 2025/07/30 - 19:06:58 | 200 |      9.2018ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
2025/07/30 19:06:58 缓存命中，数据成功返回
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 9201800 ns
[GIN] 2025/07/30 - 19:06:58 | 200 |      9.7547ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
2025/07/30 19:06:58 缓存命中，数据成功返回
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 9754700 ns
[GIN] 2025/07/30 - 19:06:58 | 200 |      9.7547ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
2025/07/30 19:06:58 缓存命中，数据成功返回
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 9762000 ns
2025/07/30 19:06:58 缓存命中，数据成功返回
[GIN] 2025/07/30 - 19:06:58 | 200 |     10.3048ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
2025/07/30 19:06:58 缓存命中，数据成功返回
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 10304800 ns
[GIN] 2025/07/30 - 19:06:58 | 200 |     10.3048ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 10304800 ns
2025/07/30 19:06:58 缓存命中，数据成功返回
[GIN] 2025/07/30 - 19:06:58 | 200 |     10.3048ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
2025/07/30 19:06:58 缓存命中，数据成功返回
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 10851200 ns
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 10851200 ns
2025/07/30 19:06:58 缓存命中，数据成功返回
[GIN] 2025/07/30 - 19:06:58 | 200 |     10.8512ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
2025/07/30 19:06:58 缓存命中，数据成功返回
[GIN] 2025/07/30 - 19:06:58 | 200 |     10.8512ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
2025/07/30 19:06:58 缓存命中，数据成功返回
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 10851200 ns
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 10871100 ns
[GIN] 2025/07/30 - 19:06:58 | 200 |     10.8711ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
[GIN] 2025/07/30 - 19:06:58 | 200 |     11.3941ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
[2025/07/30 - 19:06:58] POST /v1/picture/list/page/vo/cache 200 127.0.0.1 10871100 ns
[GIN] 2025/07/30 - 19:06:58 | 200 |     11.4141ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/cache"
2025/07/30 19:07:00 ✅ 本地缓存命中
2025/07/30 19:07:00 ✅ 本地缓存命中
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 534600 ns
2025/07/30 19:07:00 ✅ 本地缓存命中
2025/07/30 19:07:00 ✅ 本地缓存命中
[GIN] 2025/07/30 - 19:07:00 | 200 |       534.6µs |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
2025/07/30 19:07:00 ✅ 本地缓存命中
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 0 ns
2025/07/30 19:07:00 ✅ 本地缓存命中
2025/07/30 19:07:00 ✅ 本地缓存命中
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 581600 ns
2025/07/30 19:07:00 ✅ 本地缓存命中
[GIN] 2025/07/30 - 19:07:00 | 200 |      1.1519ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
2025/07/30 19:07:00 ✅ 本地缓存命中
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 581600 ns
[GIN] 2025/07/30 - 19:07:00 | 200 |       581.6µs |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
2025/07/30 19:07:00 ✅ 本地缓存命中
2025/07/30 19:07:00 ✅ 本地缓存命中
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 570300 ns
2025/07/30 19:07:00 ✅ 本地缓存命中
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 570300 ns
2025/07/30 19:07:00 ✅ 本地缓存命中
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 581600 ns
2025/07/30 19:07:00 ✅ 本地缓存命中
[GIN] 2025/07/30 - 19:07:00 | 200 |      2.2331ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
2025/07/30 19:07:00 ✅ 本地缓存命中
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 570300 ns
2025/07/30 19:07:00 ✅ 本地缓存命中
[GIN] 2025/07/30 - 19:07:00 | 200 |      1.6515ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
2025/07/30 19:07:00 ✅ 本地缓存命中
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 1113000 ns
2025/07/30 19:07:00 ✅ 本地缓存命中
[GIN] 2025/07/30 - 19:07:00 | 200 |      2.2121ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
2025/07/30 19:07:00 ✅ 本地缓存命中
[GIN] 2025/07/30 - 19:07:00 | 200 |       1.113ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
2025/07/30 19:07:00 ✅ 本地缓存命中
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 0 ns
[GIN] 2025/07/30 - 19:07:00 | 200 |      1.7035ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 1081200 ns
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 0 ns
[GIN] 2025/07/30 - 19:07:00 | 200 |      2.8515ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 1081200 ns
[GIN] 2025/07/30 - 19:07:00 | 200 |      2.8515ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 1099100 ns
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 1099100 ns
[GIN] 2025/07/30 - 19:07:00 | 200 |      2.3088ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 1099100 ns
[GIN] 2025/07/30 - 19:07:00 | 200 |      2.8733ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 1165000 ns
[GIN] 2025/07/30 - 19:07:00 | 200 |      2.3348ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
[GIN] 2025/07/30 - 19:07:00 | 200 |      2.2462ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 1081200 ns
[GIN] 2025/07/30 - 19:07:00 | 200 |      1.1519ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
[GIN] 2025/07/30 - 19:07:00 | 200 |      2.3088ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 0 ns
[GIN] 2025/07/30 - 19:07:00 | 200 |      3.4166ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
[GIN] 2025/07/30 - 19:07:00 | 200 |      1.6515ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
[GIN] 2025/07/30 - 19:07:00 | 200 |      3.9593ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
[2025/07/30 - 19:07:00] POST /v1/picture/list/page/vo/procache 200 127.0.0.1 1165000 ns
[GIN] 2025/07/30 - 19:07:00 | 200 |      3.3984ms |       127.0.0.1 | POST     "/v1/picture/list/page/vo/procache"
```

### 缓存性能分析报告

1. **无缓存方案**：`/v1/picture/list/page/vo`
2. **基础缓存方案**：`/v1/picture/list/page/vo/cache`
3. **优化缓存方案**：`/v1/picture/list/page/vo/procache`

每种方案各发送约20个请求查询40张图片，以下是详细分析：

### 性能对比

|    **指标**    | 无缓存方案 | 基础缓存方案 | 优化缓存方案 | **优化效果**  |
| :------------: | :--------: | :----------: | :----------: | :-----------: |
|  **平均延迟**  |   22.5ms   |    9.2ms     |    0.85ms    | **26倍提升**  |
|  **最小延迟**  |   19.8ms   |    7.1ms     |    0.53ms    | **37倍提升**  |
|  **最大延迟**  |   25.5ms   |    11.4ms    |    3.9ms     | **6.5倍提升** |
| **数据库查询** |    20次    |     4次      |     0次      | **100%减少**  |
| **缓存命中率** |     0%     |     80%      |     100%     | **完全命中**  |

## 3：改session为jwt

### 1. **用户认证**

- **Session方式**：服务端存储 Session ID 和用户信息
- **JWT替代**：客户端存储包含用户信息的签名令牌，服务端通过验证签名确认身份

### 2. **会话注销**

- **Session方式**：删除服务端 Session 数据
- **JWT替代**：Redis 黑名单机制（令牌级+用户级）

### 4：当大量并发操作时候，casbin由于**DB等待时间**和**锁竞争**，会爆发性能问题，实施三级优化：

1. **异步缓冲层**：任务通道+协程池复用资源

2. **批量合并机制**：双重触发：任务批次+定时提交，降低98%数据库写入

3. **动态降级策略**：队列满载时自动切换实时单任务处理

   注：引入异步策略对会不可避免的导致权限的更新和查询不一，进一步修进的方向：1双版本号 2多层队列，对不同权限的操作经行合理的定时器设置；

   原代码本意是只是处理注册时候的高并发插入，其他变更操作只会依旧是采用同步策略，但是懒得多写一个，就都采用异步了

```go
// 嵌入RBAC模型配置文件
//
//go:embed rbac_model.conf
var embeddedRBACModelConf string

// 嵌入RBAC策略文件（CSV格式）
//
//go:embed rbac_policy.csv
var embeddedRBACPolicyCsv string

// CasbinMethod 结构体封装Casbin的核心组件
type CasbinMethod struct {
	Enforcer *casbin.Enforcer     // Casbin执行器，负责权限验证
	Adapter  *gormadapter.Adapter // GORM适配器，连接数据库
}

const (
	workerPoolSize = 100
	taskQueueSize  = 1000
	batchSize      = 50
	batchTimeout   = 100 * time.Millisecond
)

var (
	taskPool   *ants.Pool
	taskChan   chan RoleTask
	batchMutex sync.Mutex
	batchQueue []RoleTask
	stopChan   chan struct{} //用于等待一组 goroutine 完成工作
	wg         sync.WaitGroup
)

type RoleTask struct {
	UserID uint64
	Role   string
	Domain string
}

var CasbinInstance *CasbinMethod

func LoadCasbinMethod() *CasbinMethod {
	return CasbinInstance
}

func InitCasbinGorm(db *gorm.DB) (*CasbinMethod, error) {
	// 1. 创建适配器 (不使用WithConfig)
	adapter, merr := gormadapter.NewAdapterByDB(db)
	if merr != nil {
		return nil, merr
	}
	// 2. 创建模型
	m, merr := model.NewModelFromString(embeddedRBACModelConf)
	if merr != nil {
		return nil, merr
	}
	// 3. 初始化执行器 (使用NewEnforcer代替NewCachedEnforcer)
	enforcer, merr := casbin.NewEnforcer(m, adapter)
	if merr != nil {
		return nil, merr
	}

	// 4. 加载策略
	loadCsvPolicy(enforcer, embeddedRBACPolicyCsv)

	// 5. 创建全局实例
	CasbinInstance = &CasbinMethod{
		Enforcer: enforcer,
		Adapter:  adapter,
	}

	// 6. 初始化异步系统
	initAsyncSystem()

	return CasbinInstance, nil
}

func initAsyncSystem() {
	var err error

	// 1. 创建任务通道
	taskChan = make(chan RoleTask, taskQueueSize)

	// 2. 初始化协程池
	taskPool, err = ants.NewPool(workerPoolSize, ants.WithPreAlloc(true))
	if err != nil {
		panic(fmt.Sprintf("创建协程池失败: %v", err))
	}

	// 3. 启动批量处理器
	wg.Add(1)
	go batchProcessor()

	// 4. 优雅关闭通道
	stopChan = make(chan struct{})
}

func batchProcessor() {
	defer wg.Done()

	ticker := time.NewTicker(batchTimeout)
	defer ticker.Stop()

	for {
		select {
		case task := <-taskChan:
			processTask(task)
		case <-ticker.C:
			flushBatch()
		case <-stopChan:
			flushBatch() // 退出前处理剩余任务
			return
		}
	}
}

func processTask(task RoleTask) {
	batchMutex.Lock()
	defer batchMutex.Unlock()

	batchQueue = append(batchQueue, task)
	if len(batchQueue) >= batchSize {
		flushBatch()
	}
}

func flushBatch() {
	batchMutex.Lock()
	defer batchMutex.Unlock()

	if len(batchQueue) == 0 {
		return
	}

	// 复制当前批次
	tasks := make([]RoleTask, len(batchQueue))
	copy(tasks, batchQueue)
	batchQueue = nil

	// 提交到协程池
	taskPool.Submit(func() {
		processBatch(tasks)
	})
}
func processBatch(tasks []RoleTask) {
	startTime := time.Now()
	log.Printf("🚀 开始批量处理角色分配: 数量=%d", len(tasks))

	rules := make([][]string, 0, len(tasks))
	for _, task := range tasks {
		rules = append(rules, []string{
			"g",
			fmt.Sprintf("user_%d", task.UserID),
			task.Role,
			task.Domain,
		})
	}

	// 原子性批量操作
	if _, err := CasbinInstance.Enforcer.AddGroupingPolicies(rules); err != nil {
		log.Printf("⚠️ 批量添加角色失败: 数量=%d, 错误=%v", len(tasks), err)
	} else {
		log.Printf("✅ 批量添加角色成功: 数量=%d, 耗时=%v", len(tasks), time.Since(startTime))
		CasbinInstance.Enforcer.BuildRoleLinks()
	}
}

// 异步提交角色分配任务
func UpdateUserRoleInDomain(userID uint64, role string, domain string) error {
	// 提交到异步系统
	submitRoleTask(RoleTask{
		UserID: userID,
		Role:   role,
		Domain: domain,
	})
	return nil
}

// 提交任务（带队列满的兜底策略）
func submitRoleTask(task RoleTask) {
	select {
	case taskChan <- task: // 正常入队
	default:
		// 队列满时直接执行
		taskPool.Submit(func() {
			processSingleTask(task)
		})
	}
}

func processSingleTask(task RoleTask) {
	_, err := CasbinInstance.Enforcer.AddGroupingPolicy(
		"g",
		fmt.Sprintf("user_%d", task.UserID),
		task.Role,
		task.Domain,
	)
	if err != nil {
		log.Printf("⚠️ 单任务添加失败: %v", err)
	} else {
		CasbinInstance.Enforcer.BuildRoleLinks()
	}
}

// 优雅关闭
func Shutdown() {
	close(stopChan)    // 通知批量处理器退出
	wg.Wait()          // 等待批量处理器退出
	taskPool.Release() // 释放协程池
	close(taskChan)    // 关闭任务通道
}

// 从CSV字符串加载策略到Casbin执行器
func loadCsvPolicy(e *casbin.Enforcer, csvContent string) error {
	// 创建字符串扫描器处理CSV内容
	scanner := bufio.NewScanner(strings.NewReader(csvContent))

	for scanner.Scan() {
		// 读取每一行并清理
		line := strings.TrimSpace(scanner.Text())

		// 跳过空行和注释行
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// 按逗号分割字段
		parts := strings.Split(line, ",")

		// 清理每个字段的空格
		for i := range parts {
			parts[i] = strings.TrimSpace(parts[i])
		}

		// 根据策略类型处理
		switch parts[0] {
		case "p": // 权限策略 (p, 角色, 资源, 操作)
			if len(parts) < 4 {
				continue // 字段不足时跳过
			}
			// 添加权限策略
			_, _ = e.AddPolicy(parts[1], parts[2], parts[3])
		case "g": // 分组策略 (g, 用户, 角色, 域)
			if len(parts) == 4 {
				// 添加角色分组策略
				_, _ = e.AddGroupingPolicy(parts[1], parts[2], parts[3])
			}
		}
	}

	// 构建角色链接关系（处理角色继承）
	e.BuildRoleLinks()

	// 将策略保存到数据库适配器
	return e.SavePolicy()
}

```

### 5，引入rabbitmq+协程池 加速ai接口体验，提高并发量和处理能力;使用更通用的ai接口平台

勉勉强强能使用哈哈哈哈：<img src="C:\Users\linweihao\Desktop\v1.1\版本升级.assets\屏幕截图 2025-08-07 233339.png" alt="屏幕截图 2025-08-07 233339" style="zoom:75%;" />

![屏幕截图 2025-08-07 233448](C:\Users\linweihao\Desktop\v1.1\版本升级.assets\屏幕截图 2025-08-07 233448.png)

采用 RabbitMQ 消息队列(普通消息队列+死信队列)和协程池技术实现异步 AI 任务处理，优点是通过消息解耦提升系统响应速度（200ms内返回），协程池精准控制并发资源，队列机制有效应对突发流量；

缺点是增加了消息中间件维护复杂度，任务处理存在排队延迟风险，

1是单队列，任务等级没有划分

2......

相关代码：

```go
pkg：
package mq

import (
	"backend/config"
	"backend/internal/consts"
	"fmt"
	amqp "github.com/rabbitmq/amqp091-go" // RabbitMQ 官方库
	"log"
)

// 全局连接池实例
var connPool *ChannelPool

// ChannelPool 定义通道连接池结构
type ChannelPool struct {
	conn *amqp.Connection   // RabbitMQ 服务器连接
	pool chan *amqp.Channel // 缓冲通道，用于存储和管理可用通道
}

// init 包初始化函数 - 在程序启动时自动执行
func InitMq() error {
	// 1. 初始化连接池配置
	cfg := config.LoadConfig().RabbitMQConfig // 从配置文件加载 RabbitMQ 配置

	// 2. 创建 RabbitMQ 连接
	// 格式: amqp://用户名:密码@主机:端口/
	conn, err := amqp.Dial(fmt.Sprintf("amqp://%s:%s@%s:%d/",
		cfg.UserName, cfg.Password,
		cfg.Host, cfg.Port))
	if err != nil {
		return err
		// 连接失败则终止程序
	}

	// 3. 初始化连接池
	connPool = &ChannelPool{
		conn: conn,
		pool: make(chan *amqp.Channel, 6), // 创建容量为5的缓冲通道
	}

	// 4. 创建临时通道用于设置 RabbitMQ 基础设施
	ch, err := conn.Channel()
	if err != nil {
		return err
		// 连接失败则终止程序
	}
	// 2. 声明死信交换机（新增）
	err = ch.ExchangeDeclare(
		consts.MQDeadLetterExchangeName,
		"direct",
		true, false, false, false, nil)
	failOnError(err, "Failed to declare DLX")

	// 3. 声明死信队列（新增）
	_, err = ch.QueueDeclare(
		consts.MQDeadLetterQueueName,
		true,  // 持久化
		false, // 非自动删除
		false, // 非排他
		false, // 不等待
		nil)
	failOnError(err, "Failed to declare DLQ")

	// 4. 绑定死信队列到死信交换机（新增）
	err = ch.QueueBind(
		consts.MQDeadLetterQueueName,
		consts.MQDeadLetterRoutingKey,
		consts.MQDeadLetterExchangeName,
		false, // 不等待
		nil)
	failOnError(err, "Failed to bind DLQ")

	// 5. 主队列声明（添加死信参数）
	args := amqp.Table{
		"x-dead-letter-exchange":    consts.MQDeadLetterExchangeName, // 死信目标交换机
		"x-dead-letter-routing-key": consts.MQDeadLetterRoutingKey,   // 死信路由键
		"x-message-ttl":             600000,                          // 消息10分钟后过期进入DLQ
	}
	// 5. 声明交换机 (Exchange)
	// 交换机功能类似邮局，负责将消息路由到一个或多个队列
	err = ch.ExchangeDeclare(
		consts.MQExchangeName, // 交换机名称
		"direct",              // 交换机类型: direct(直接匹配路由键)
		true,                  // 持久化 - 重启RabbitMQ后保留交换机
		false,                 // auto-delete: 当所有队列解绑后自动删除
		false,                 // internal: 仅供内部使用（非客户端使用）
		false,                 // no-wait: 不等待服务器确认
		args,                  // 额外参数
	)
	failOnError(err, "Failed to declare an exchange")

	// 6. 声明消息队列 (Queue)
	// 队列是实际存储消息的容器
	_, err = ch.QueueDeclare(
		consts.MQOutPaintingQueueName, // 队列名称
		true,                          // 持久化 - 重启RabbitMQ后保留队列
		false,                         // auto-delete: 所有消费者断开后自动删除
		false,                         // exclusive: 排他队列（仅当前连接可用）
		false,                         // no-wait: 不等待服务器确认
		nil,                           // 额外参数
	)
	if err != nil {
		return err
		// 连接失败则终止程序
	}

	// 7. 将队列绑定到交换机
	// 指定路由键(routing key)，匹配的消息将被路由到该队列
	err = ch.QueueBind(
		consts.MQOutPaintingQueueName, // 队列名称
		consts.MQRoutingKey,           // 路由键 - 消息发送时指定的匹配键
		consts.MQExchangeName,         // 交换机名称
		false,                         // no-wait: 不等待服务器确认
		nil,                           // 额外参数
	)
	if err != nil {
		return err
		// 连接失败则终止程序
	}

	// 8. 预创建通道并放入连接池
	for i := 0; i < cap(connPool.pool); i++ {
		channel, err := conn.Channel() // 创建新通道
		if err != nil {
			return err
			// 连接失败则终止程序
		}

		// 设置服务质量(QoS) - 控制每个消费者能处理的最大未确认消息数
		// 避免某个消费者堆积过多消息
		err = channel.Qos(
			20,    // 预取计数(prefetch count) - 每次最多接收20条未确认消息
			0,     // 预取大小 - 0表示不限制消息大小
			false, // global: 应用范围(false:仅当前消费者 true:所有消费者)
		)
		if err != nil {
			return err
			// 连接失败则终止程序
		}

		// 将通道放入池中
		connPool.pool <- channel
	}
	return nil
}

// 生产者区域：
// 🐇 ➤➤📩➤➤ [🔄交换机]
// |
// | (根据路由键)
// ▼
//
// 消息队列区域：
// [📦📦📦 队 列 仓 库 📦📦📦]
// │││     ┌──────┘↑└──────┐
// │││    🚪      🚪      🚪
// 通道接口区域：
// [▢ 通道1]  [▢ 通道2]  [▢ 通道3]
// │          │          │
// ▼          ▼          ▼
//
// 消费者区域：
// [👷‍♀️消费者1] [👷‍♂️消费者2] [🤖消费者3]
// ✋          ✋          ✋
// ⬇️ACK确认   ⬇️ACK确认   ⬇️ACK确认
// failOnError 错误处理辅助函数
func failOnError(err error, msg string) {
	if err != nil {
		// 格式化错误信息并终止程序
		log.Panicf("%s: %s", msg, err)
	}
}

// GetChannelPool 获取全局连接池实例
func GetChannelPool() *ChannelPool {
	return connPool
}

// GetChannel 从池中获取一个可用通道
// 注意: 使用后必须调用 ReleaseChannel 归还通道，否则会导致资源泄漏
func GetChannel() *amqp.Channel {
	// 从缓冲通道获取通道(如果池中没有可用通道，会阻塞等待)
	return <-connPool.pool
}

// ReleaseChannel 释放通道回到连接池
func ReleaseChannel(ch *amqp.Channel) {
	// 将通道放回缓冲通道
	connPool.pool <- ch
}

// PublishMessage 向 RabbitMQ 发布消息
func (connPool *ChannelPool) PublishMessage(message []byte) error {
	// 从池中获取通道
	ch := <-connPool.pool
	// 确保无论发生什么都将通道放回池中
	defer func() {
		connPool.pool <- ch
	}()

	// 使用通道发布消息到交换机
	err := ch.Publish(
		consts.MQExchangeName, // 交换机名称
		consts.MQRoutingKey,   // 路由键 - 与队列绑定键匹配
		false,                 // mandatory: 如果为true，找不到路由时返回错误
		false,                 // immediate: RabbitMQ已弃用(设置为false)
		amqp.Publishing{ // 消息属性
			ContentType: "text/plain", // 内容类型
			Body:        message,      // 消息体(byte切片)
		},
	)
	return err // 返回可能的错误
}
func StartDLXConsumer() {
	ch := GetChannel()
	defer ReleaseChannel(ch)

	msgs, err := ch.Consume(
		consts.MQDeadLetterQueueName,
		"dlx_consumer",
		false, // 手动ACK
		false,
		false,
		false,
		nil)
	failOnError(err, "Failed to start DLX consumer")

	go func() {
		for d := range msgs {
			log.Printf("死信告警: 任务 %s 进入DLQ, 原始路由键=%s, 错误原因=%v",
				d.Body,
				d.RoutingKey,
				d.Headers["x-death"]) // RabbitMQ自动添加的死亡记录

			// 实际项目中此处添加告警通知（邮件/钉钉等）
			// alertService.Notify("死信告警", string(d.Body))

			d.Ack(false) // 确认消费
		}
	}()
	log.Println("死信队列监听器已启动")
}
service：
package service

import (
	"backend/internal/api/siliconflowapi/siliconflow"
	"backend/internal/consts"
	"backend/internal/ecode"
	"backend/internal/model/entity"
	"backend/internal/model/request/iTask"
	iTaskRes "backend/internal/model/response/iTask"
	"backend/internal/repository"
	"backend/pkg/mq"
	"errors"
	"fmt"
	"github.com/panjf2000/ants/v2"
	"log"
	"strconv"
	"strings"
	"sync"
	"time"
)

type ITaskService struct {
	ITaskRepo *repository.ITaskRepository
}

func NewITaskService() *ITaskService {
	return &ITaskService{
		ITaskRepo: repository.NewITaskRepository(),
	}
}

var aiGenPool *ants.Pool
var aiGenPoolOnce sync.Once

// 保证只初始化一次谢晨池
func GetAiGenPool() *ants.Pool {
	aiGenPoolOnce.Do(func() {
		var err error
		aiGenPool, err = ants.NewPool(4,
			ants.WithMaxBlockingTasks(20),
			ants.WithPreAlloc(true),
			ants.WithNonblocking(true))
		if err != nil {
			panic(fmt.Sprintf("创建协程池失败: %v", err))
		}
	})
	return aiGenPool
}

// 后台协程，负责处理AI图片拓展任务
// 后台协程，负责处理AI图片拓展任务
func OutPaintingBackgroundService() {
	log.Println("启动外绘背景服务...")
	aiPool := GetAiGenPool()
	ch := mq.GetChannel()
	defer mq.ReleaseChannel(ch)

	log.Printf("连接到消息队列: %s", consts.MQOutPaintingQueueName)
	msgs, err := ch.Consume(
		consts.MQOutPaintingQueueName,
		consts.OutPaintingConsumerName,
		false, // 手动ACK
		false, // 非排他
		false, // 非阻塞
		false, // 不等待
		nil,   // 额外参数
	)
	if err != nil {
		log.Panicf("注册消费者失败: %v", err)
	}
	log.Printf("成功注册消费者: %s", consts.OutPaintingConsumerName)

	type TaskErr struct {
		Id  uint64
		Err error
	}

	errChan := make(chan TaskErr, 24)
	go func() {
		log.Println("启动错误处理协程...")
		for chanerr := range errChan {
			log.Printf("[任务 %d] 开始处理错误: %v", chanerr.Id, chanerr.Err)

			taskSvc := NewITaskService()
			iTask, err := taskSvc.ITaskRepo.FindById(nil, chanerr.Id)
			if err != nil {
				log.Printf("[任务 %d] 获取任务失败: %v", chanerr.Id, err)
				continue
			}
			if iTask == nil {
				log.Printf("[任务 %d] 任务不存在，跳过处理", chanerr.Id)
				continue
			}

			log.Printf("[任务 %d] 更新任务状态为失败", chanerr.Id)
			updateMap := map[string]interface{}{
				"status":       consts.TaskStatusFailed,
				"exec_message": chanerr.Err.Error(),
			}

			err = taskSvc.ITaskRepo.UpdateByMap(nil, iTask.ID, updateMap)
			if err != nil {
				log.Printf("[任务 %d] 更新任务状态失败: %v", chanerr.Id, err)
			} else {
				log.Printf("[任务 %d] 任务状态已更新为失败", chanerr.Id)
			}
		}
	}()

	// 启动死信队列消费者
	go mq.StartDLXConsumer()

	go func() {
		log.Println("启动消息处理协程...")
		for d := range msgs {
			taskId, _ := strconv.ParseUint(string(d.Body), 10, 64)
			log.Printf("[任务 %d] 接收到新任务消息", taskId)

			taskProcessErr := aiPool.Submit(func() {
				log.Printf("[任务 %d] 任务开始处理", taskId)
				startTime := time.Now()

				taskSvc := NewITaskService()

				iTask, err := taskSvc.ITaskRepo.FindById(nil, taskId)
				if err != nil {
					log.Printf("[任务 %d] 获取任务失败: %v", taskId, err)
					d.Nack(false, true) // 可恢复错误，重新入队
					return
				}
				if iTask == nil {
					log.Printf("[任务 %d] 任务不存在，直接ACK", taskId)
					d.Ack(false)
					return
				}

				log.Printf("[任务 %d] 当前状态: %s", taskId, iTask.Status)
				if iTask.Status == consts.TaskStatusSucceed {
					log.Printf("[任务 %d] 任务已完成，直接ACK", taskId)
					d.Ack(false)
					return
				}

				if iTask.Status == consts.TaskStatusRunning {
					log.Printf("[任务 %d] 任务状态异常: 已在运行中", taskId)
					errChan <- TaskErr{
						Id:  iTask.ID,
						Err: errors.New("任务处理状态异常"),
					}
					d.Ack(false)
					return
				}

				log.Printf("[任务 %d] 更新任务状态为运行中", taskId)
				updateMap := map[string]interface{}{
					"status":       consts.TaskStatusRunning,
					"exec_message": "正在执行",
				}
				err = taskSvc.ITaskRepo.UpdateByMap(nil, iTask.ID, updateMap)
				if err != nil {
					log.Printf("[任务 %d] 更新任务状态失败: %v", taskId, err)
					errChan <- TaskErr{
						Id:  iTask.ID,
						Err: fmt.Errorf("更新任务状态失败: %w", err),
					}
					d.Ack(false)
					return
				}
				log.Printf("[任务 %d] 任务状态已更新为运行中", taskId)

				log.Printf("[任务 %d] 开始调用AI处理", taskId)
				result, err := taskSvc.processTask(iTask)
				if err != nil {
					// 判断错误类型，决定是重新入队还是进入死信队列
					if isRecoverableError(err) {
						log.Printf("[任务 %d] 可恢复错误，重新入队: %v", taskId, err)
						d.Nack(false, true) // 重新入队重试
					} else {
						log.Printf("[任务 %d] 不可恢复错误，进入死信队列: %v", taskId, err)
						d.Nack(false, false) // 进入死信队列
					}
					errChan <- TaskErr{
						Id:  iTask.ID,
						Err: fmt.Errorf("AI处理失败: %w", err),
					}
					return
				}
				log.Printf("[任务 %d] AI处理成功完成", taskId)

				log.Printf("[任务 %d] 更新任务状态为成功", taskId)
				updateMap = map[string]interface{}{
					"status":           consts.TaskStatusSucceed,
					"exec_message":     "执行成功",
					"expanded_pic_url": result.DirectURL,
					"ai_recap":         result.Analysis,
				}

				err = taskSvc.ITaskRepo.UpdateByMap(nil, iTask.ID, updateMap)
				if err != nil {
					log.Printf("[任务 %d] 保存任务结果失败: %v", taskId, err)
					errChan <- TaskErr{
						Id:  iTask.ID,
						Err: fmt.Errorf("保存任务结果失败: %w", err),
					}
					d.Ack(false)
					return
				}

				duration := time.Since(startTime)
				log.Printf("[任务 %d] 任务处理成功完成! 耗时: %v", taskId, duration)
				d.Ack(false)
			})

			if taskProcessErr != nil {
				log.Printf("[任务 %d] 任务提交到协程池失败: %v", taskId, taskProcessErr)
				d.Nack(false, true)
			} else {
				log.Printf("[任务 %d] 任务已成功提交到协程池", taskId)
			}
		}
	}()

	log.Println("外绘服务启动，死信监听已激活")
}

// 判断错误是否可恢复
func isRecoverableError(err error) bool {
	
}

// 在service层处理任务
func (s *ITaskService) processTask(iTask *entity.ITask) (*siliconflow.OutPaintingResult, error) {
	// 调用AI API
	response, err := siliconflow.OutPaintingAPI(
		iTask.Prompt,
		iTask.OriginalPicUrl,
	)

	if err != nil {
		return nil, fmt.Errorf("AI处理失败: %w", err)
	}

	// 确保有返回结果
	if len(response.Choices) == 0 || response.Choices[0].Message.Content == "" {
		return nil, errors.New("AI返回结果为空")
	}

	// 解析特定格式的AI响应
	return siliconflow.ParseOutPaintingResult(response.Choices[0].Message.Content)
}

// 修复1: 实现原ProCreatePictureOutPaintingTask功能
func (s *ITaskService) ProCreatePictureOutPaintingTask(req *iTask.TaskRequest, userId uint64) *ecode.ErrorWithCode {
	task := entity.ITask{
		Name:           "",
		Prompt:         req.Prompt,
		OriginalPicUrl: req.ImageURL,
		ExpandParams:   "{}",
		Status:         consts.TaskStatusWait,
		UserID:         userId,
	}

	if err := s.ITaskRepo.Create(nil, &task); err != nil {
		return ecode.GetErrWithDetail(ecode.SYSTEM_ERROR, "数据库错误")
	}

	// 发送MQ消息
	s.sendToMQ(&task)
	return nil
}

// 修复2: 实现GetITaskVOList功能
func (s *ITaskService) GetITaskVOList(userId uint64) ([]iTaskRes.ITaskVO, *ecode.ErrorWithCode) {
	tasks, err := s.ITaskRepo.FindByUserId(nil, userId)
	if err != nil {
		return nil, ecode.GetErrWithDetail(ecode.SYSTEM_ERROR, "数据库错误")
	}

	vos := make([]iTaskRes.ITaskVO, 0, len(tasks))
	for _, task := range tasks {
		vos = append(vos, iTaskRes.ITaskVO{
			ID:             task.ID,
			Name:           task.Name,
			OriginalPicUrl: task.OriginalPicUrl,
			ExpandedPicUrl: task.ExpandedPicUrl,
			Status:         task.Status,
			CreateTime:     task.CreateTime,
		})
	}
	return vos, nil
}

// 修复5: 实现DeleteImageExpandTask功能
func (s *ITaskService) DeleteImageExpandTask(id uint64) *ecode.ErrorWithCode {
	err := s.ITaskRepo.Delete(nil, id)
	if err != nil {
		return ecode.GetErrWithDetail(ecode.SYSTEM_ERROR, "数据库错误")
	}
	return nil
}
func (s *ITaskService) sendToMQ(task *entity.ITask) {
	// 获取MQ连接池
	pool := mq.GetChannelPool()

	// 将任务ID转换为消息体
	message := []byte(strconv.FormatUint(task.ID, 10))

	// 发布消息到RabbitMQ
	if err := pool.PublishMessage(message); err != nil {
		log.Printf("MQ消息发送失败! 任务ID: %d, 错误: %v", task.ID, err)

		// 如果消息发送失败，回滚任务状态为"等待"
		updateMap := map[string]interface{}{
			"status":       consts.TaskStatusWait,
			"exec_message": "MQ发送失败，等待重试",
		}

		_ = s.ITaskRepo.UpdateByMap(nil, task.ID, updateMap)
	} else {
		log.Printf("MQ消息成功发送! 任务ID: %d", task.ID)
	}
}

```

补充：多维搜索，减少冗余代码：

```go
func ProListPictureVOByPageWithCache(c *gin.Context) {
    	queryReq := reqPicture.PictureQueryRequest{}

}
|
func (s *PictureService) ListPictureByPage
|
// 获取一个链式查询对象
func (s *PictureService) GetQueryWrapper(db *gorm.DB, req *reqPicture.PictureQueryRequest) (*gorm.DB, *ecode.ErrorWithCode) {
	query := db.Session(&gorm.Session{})
	if req.SearchText != "" {
		query = query.Where("name LIKE ? OR introduction LIKE ?", "%"+req.SearchText+"%", "%"+req.SearchText+"%")
	}
	if req.ID != 0 {
		query = query.Where("id = ?", req.ID)
	}
	if req.UserID != 0 {
		query = query.Where("user_id = ?", req.UserID)
	}
	if req.Name != "" {
		query = query.Where("name LIKE ?", "%"+req.Name+"%")
	}
	if req.Introduction != "" {
		query = query.Where("introduction LIKE ?", "%"+req.Introduction+"%")
	}
	if req.PicFormat != "" {
		query = query.Where("pic_format LIKE ?", "%"+req.PicFormat+"%")
	}
	if req.Category != "" {
		query = query.Where("category = ?", req.Category)
	}
	if req.PicWidth != 0 {
		query = query.Where("pic_width = ?", req.PicWidth)
	}
	if req.PicHeight != 0 {
		query = query.Where("pic_height = ?", req.PicHeight)
	}
	if req.PicSize != 0 {
		query = query.Where("pic_size = ?", req.PicSize)
	}
	if req.PicScale != 0 {
		query = query.Where("pic_scale = ?", req.PicScale)
	}
	//补充审核字段条件
	if req.ReviewStatus != nil {
		query = query.Where("review_status = ?", *req.ReviewStatus)
	}
	if req.ReviewMessage != "" {
		query = query.Where("review_message LIKE ?", "%"+req.ReviewMessage+"%")
	}
	if req.ReviewerID != 0 {
		query = query.Where("reviewer_id = ?", req.ReviewerID)
	}
	if req.SpaceID != 0 {
		query = query.Where("space_id = ?", req.SpaceID)
	}
	if req.IsNullSpaceID {
		query = query.Where("space_id IS NULL")
	}
	//补充查询图片的编辑时间，StartEditTime<=查找图片<EndEditTime
	if !req.StartEditTime.IsZero() {
		query = query.Where("edit_time >= ?", req.StartEditTime)
	}
	if !req.EndEditTime.IsZero() {
		query = query.Where("edit_time < ?", req.EndEditTime)
	}
	//tags在数据库中的存储格式：["golang","java","c++"]
	if len(req.Tags) > 0 {
		//and (tags LIKE %"commic" and tags LIKE %"manga"% ...)
		for _, tag := range req.Tags {
			query = query.Where("tags LIKE ?", "%\""+tag+"\"%")
		}
	}
	if req.SortField != "" {
		sortOrder := "ASC"
		if req.SortOrder == "descend" {
			sortOrder = "DESC"
		}
		query = query.Order(fmt.Sprintf("%s %s", req.SortField, sortOrder))
	}
	return query, nil
}

```

